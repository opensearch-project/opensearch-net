/* SPDX-License-Identifier: Apache-2.0
*
* The OpenSearch Contributors require contributions made to
* this file be licensed under the Apache-2.0 license or a
* compatible open source license.
*/
/*
* Modifications Copyright OpenSearch Contributors. See
* GitHub history for details.
*
*  Licensed to Elasticsearch B.V. under one or more contributor
*  license agreements. See the NOTICE file distributed with
*  this work for additional information regarding copyright
*  ownership. Elasticsearch B.V. licenses this file to you under
*  the Apache License, Version 2.0 (the "License"); you may
*  not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing,
*  software distributed under the License is distributed on an
*  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
*  KIND, either express or implied.  See the License for the
*  specific language governing permissions and limitations
*  under the License.
*/
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// -----------------------------------------------
//
// This file is automatically generated
// Please do not edit these files manually
// Run the following in the root of the repos:
//
//      *NIX        :   ./build.sh codegen
//      Windows     :   build.bat codegen
//
// -----------------------------------------------
// ReSharper disable RedundantUsingDirective
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using OpenSearch.Net;
using OpenSearch.Net.Specification.IndicesApi;
using OpenSearch.Net.Utf8Json;

// ReSharper disable RedundantBaseConstructorCall
// ReSharper disable UnusedTypeParameter
// ReSharper disable PartialMethodWithSinglePart
// ReSharper disable RedundantNameQualifier
namespace OpenSearch.Client
{
    /// <summary>Descriptor for AddBlock <para>https://opensearch.org/docs/latest</para></summary>
    public partial class AddIndexBlockDescriptor
        : RequestDescriptorBase<
            AddIndexBlockDescriptor,
            AddIndexBlockRequestParameters,
            IAddIndexBlockRequest
        >,
            IAddIndexBlockRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesAddBlock;

        /// <summary>/{index}/_block/{block}</summary>
        /// <param name="index">this parameter is required</param>
        /// <param name="block">this parameter is required</param>
        public AddIndexBlockDescriptor(Indices index, IndexBlock block)
            : base(r => r.Required("index", index).Required("block", block)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected AddIndexBlockDescriptor()
            : base() { }

        // values part of the url path
        IndexBlock IAddIndexBlockRequest.Block => Self.RouteValues.Get<IndexBlock>("block");
        Indices IAddIndexBlockRequest.Index => Self.RouteValues.Get<Indices>("index");

        /// <summary>A comma separated list of indexes to add a block to.</summary>
        public AddIndexBlockDescriptor Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Required("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public AddIndexBlockDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public AddIndexBlockDescriptor AllIndices() => Index(Indices.All);

        // Request parameters
        /// <summary>Whether to ignore if a wildcard indexes expression resolves into no concrete indexes. (This includes `_all` string or when no indexes have been specified).</summary>
        public AddIndexBlockDescriptor AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public AddIndexBlockDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Whether to expand wildcard expression to concrete indexes that are open, closed or both.</summary>
        public AddIndexBlockDescriptor ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);

        /// <summary>Whether specified concrete indexes should be ignored when unavailable (missing or closed).</summary>
        public AddIndexBlockDescriptor IgnoreUnavailable(bool? ignoreunavailable = true) =>
            Qs("ignore_unavailable", ignoreunavailable);

        /// <summary>Specify timeout for connection to cluster manager.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public AddIndexBlockDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);

        /// <summary>Explicit operation timeout.</summary>
        public AddIndexBlockDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
    }

    /// <summary>Descriptor for Analyze <para>https://opensearch.org/docs/latest/api-reference/analyze-apis/perform-text-analysis/</para></summary>
    public partial class AnalyzeDescriptor
        : RequestDescriptorBase<AnalyzeDescriptor, AnalyzeRequestParameters, IAnalyzeRequest>,
            IAnalyzeRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesAnalyze;

        /// <summary>/_analyze</summary>
        public AnalyzeDescriptor()
            : base() { }

        /// <summary>/{index}/_analyze</summary>
        /// <param name="index">Optional, accepts null</param>
        public AnalyzeDescriptor(IndexName index)
            : base(r => r.Optional("index", index)) { }

        // values part of the url path
        IndexName IAnalyzeRequest.Index => Self.RouteValues.Get<IndexName>("index");

        /// <summary>Index used to derive the analyzer. If specified, the `analyzer` or field parameter overrides this value. If no index is specified or the index does not have a default analyzer, the analyze API uses the standard analyzer.</summary>
        public AnalyzeDescriptor Index(IndexName index) =>
            Assign(index, (a, v) => a.RouteValues.Optional("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public AnalyzeDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (IndexName)v));
        // Request parameters
    }

    /// <summary>Descriptor for ClearCache <para>https://opensearch.org/docs/latest/api-reference/index-apis/clear-index-cache/</para></summary>
    public partial class ClearCacheDescriptor
        : RequestDescriptorBase<
            ClearCacheDescriptor,
            ClearCacheRequestParameters,
            IClearCacheRequest
        >,
            IClearCacheRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesClearCache;

        /// <summary>/_cache/clear</summary>
        public ClearCacheDescriptor()
            : base() { }

        /// <summary>/{index}/_cache/clear</summary>
        /// <param name="index">Optional, accepts null</param>
        public ClearCacheDescriptor(Indices index)
            : base(r => r.Optional("index", index)) { }

        // values part of the url path
        Indices IClearCacheRequest.Index => Self.RouteValues.Get<Indices>("index");

        /// <summary>Comma-separated list of data streams, indexes, and aliases used to limit the request. Supports wildcards (`*`). To target all data streams and indexes, omit this parameter or use `*` or `_all`.</summary>
        public ClearCacheDescriptor Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Optional("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public ClearCacheDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public ClearCacheDescriptor AllIndices() => Index(Indices.All);

        // Request parameters
        /// <summary>If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indexes. This behavior applies even if the request targets other open indexes.</summary>
        public ClearCacheDescriptor AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`. Valid values are: `all`, `open`, `closed`, `hidden`, `none`.</summary>
        public ClearCacheDescriptor ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);

        /// <summary>If `true`, clears the fields cache. Use the `fields` parameter to clear the cache of specific fields only.</summary>
        public ClearCacheDescriptor Fielddata(bool? fielddata = true) => Qs("fielddata", fielddata);

        /// <summary>Comma-separated list of field names used to limit the `fielddata` parameter.</summary>
        public ClearCacheDescriptor Fields(Fields fields) => Qs("fields", fields);

        /// <summary>Comma-separated list of field names used to limit the `fielddata` parameter.</summary>
        public ClearCacheDescriptor Fields<T>(params Expression<Func<T, object>>[] fields)
            where T : class => Qs("fields", fields?.Select(e => (Field)e));

        /// <summary>If `true`, clears the unused entries from the file cache on nodes with the Search role.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.8.0 or greater.</remarks>
        public ClearCacheDescriptor File(bool? file = true) => Qs("file", file);

        /// <summary>If `false`, the request returns an error if it targets a missing or closed index.</summary>
        public ClearCacheDescriptor IgnoreUnavailable(bool? ignoreunavailable = true) =>
            Qs("ignore_unavailable", ignoreunavailable);

        /// <summary>If `true`, clears the query cache.</summary>
        public ClearCacheDescriptor Query(bool? query = true) => Qs("query", query);

        /// <summary>If `true`, clears the request cache.</summary>
        public ClearCacheDescriptor Request(bool? request = true) => Qs("request", request);
    }

    /// <summary>Descriptor for Clone <para>https://opensearch.org/docs/latest/api-reference/index-apis/clone/</para></summary>
    public partial class CloneIndexDescriptor
        : RequestDescriptorBase<
            CloneIndexDescriptor,
            CloneIndexRequestParameters,
            ICloneIndexRequest
        >,
            ICloneIndexRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesClone;

        /// <summary>/{index}/_clone/{target}</summary>
        /// <param name="index">this parameter is required</param>
        /// <param name="target">this parameter is required</param>
        public CloneIndexDescriptor(IndexName index, IndexName target)
            : base(r => r.Required("index", index).Required("target", target)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected CloneIndexDescriptor()
            : base() { }

        // values part of the url path
        IndexName ICloneIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
        IndexName ICloneIndexRequest.Target => Self.RouteValues.Get<IndexName>("target");

        /// <summary>Name of the source index to clone.</summary>
        public CloneIndexDescriptor Index(IndexName index) =>
            Assign(index, (a, v) => a.RouteValues.Required("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public CloneIndexDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));

        // Request parameters
        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public CloneIndexDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public CloneIndexDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);

        /// <summary>Explicit task execution timeout, only useful when `wait_for_completion` is false, defaults to `1h`.</summary>
        public CloneIndexDescriptor TaskExecutionTimeout(Time taskexecutiontimeout) =>
            Qs("task_execution_timeout", taskexecutiontimeout);

        /// <summary>Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        public CloneIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);

        /// <summary>The number of shard copies that must be active before proceeding with the operation. Set to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).</summary>
        public CloneIndexDescriptor WaitForActiveShards(string waitforactiveshards) =>
            Qs("wait_for_active_shards", waitforactiveshards);

        /// <summary>Should this request wait until the operation has completed before returning.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.7.0 or greater.</remarks>
        public CloneIndexDescriptor WaitForCompletion(bool? waitforcompletion = true) =>
            Qs("wait_for_completion", waitforcompletion);
    }

    /// <summary>Descriptor for Close <para>https://opensearch.org/docs/latest/api-reference/index-apis/close-index/</para></summary>
    public partial class CloseIndexDescriptor
        : RequestDescriptorBase<
            CloseIndexDescriptor,
            CloseIndexRequestParameters,
            ICloseIndexRequest
        >,
            ICloseIndexRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesClose;

        /// <summary>/{index}/_close</summary>
        /// <param name="index">this parameter is required</param>
        public CloseIndexDescriptor(Indices index)
            : base(r => r.Required("index", index)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected CloseIndexDescriptor()
            : base() { }

        // values part of the url path
        Indices ICloseIndexRequest.Index => Self.RouteValues.Get<Indices>("index");

        /// <summary>Comma-separated list or wildcard expression of index names used to limit the request.</summary>
        public CloseIndexDescriptor Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Required("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public CloseIndexDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public CloseIndexDescriptor AllIndices() => Index(Indices.All);

        // Request parameters
        /// <summary>If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indexes. This behavior applies even if the request targets other open indexes.</summary>
        public CloseIndexDescriptor AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public CloseIndexDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`. Valid values are: `all`, `open`, `closed`, `hidden`, `none`.</summary>
        public CloseIndexDescriptor ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);

        /// <summary>If `false`, the request returns an error if it targets a missing or closed index.</summary>
        public CloseIndexDescriptor IgnoreUnavailable(bool? ignoreunavailable = true) =>
            Qs("ignore_unavailable", ignoreunavailable);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public CloseIndexDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);

        /// <summary>Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        public CloseIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);

        /// <summary>The number of shard copies that must be active before proceeding with the operation. Set to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).</summary>
        public CloseIndexDescriptor WaitForActiveShards(string waitforactiveshards) =>
            Qs("wait_for_active_shards", waitforactiveshards);
    }

    /// <summary>Descriptor for Create <para>https://opensearch.org/docs/latest/api-reference/index-apis/create-index/</para></summary>
    public partial class CreateIndexDescriptor
        : RequestDescriptorBase<
            CreateIndexDescriptor,
            CreateIndexRequestParameters,
            ICreateIndexRequest
        >,
            ICreateIndexRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesCreate;

        /// <summary>/{index}</summary>
        /// <param name="index">this parameter is required</param>
        public CreateIndexDescriptor(IndexName index)
            : base(r => r.Required("index", index)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected CreateIndexDescriptor()
            : base() { }

        // values part of the url path
        IndexName ICreateIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");

        /// <summary>Name of the index you wish to create.</summary>
        public CreateIndexDescriptor Index(IndexName index) =>
            Assign(index, (a, v) => a.RouteValues.Required("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public CreateIndexDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));

        // Request parameters
        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public CreateIndexDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public CreateIndexDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);

        /// <summary>Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        public CreateIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);

        /// <summary>The number of shard copies that must be active before proceeding with the operation. Set to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).</summary>
        public CreateIndexDescriptor WaitForActiveShards(string waitforactiveshards) =>
            Qs("wait_for_active_shards", waitforactiveshards);
    }

    /// <summary>Descriptor for Delete <para>https://opensearch.org/docs/latest/api-reference/index-apis/delete-index/</para></summary>
    public partial class DeleteIndexDescriptor
        : RequestDescriptorBase<
            DeleteIndexDescriptor,
            DeleteIndexRequestParameters,
            IDeleteIndexRequest
        >,
            IDeleteIndexRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesDelete;

        /// <summary>/{index}</summary>
        /// <param name="index">this parameter is required</param>
        public DeleteIndexDescriptor(Indices index)
            : base(r => r.Required("index", index)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected DeleteIndexDescriptor()
            : base() { }

        // values part of the url path
        Indices IDeleteIndexRequest.Index => Self.RouteValues.Get<Indices>("index");

        /// <summary>Comma-separated list of indexes to delete. You cannot specify index aliases. By default, this parameter does not support wildcards (`*`) or `_all`. To use wildcards or `_all`, set the `action.destructive_requires_name` cluster setting to `false`.</summary>
        public DeleteIndexDescriptor Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Required("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public DeleteIndexDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public DeleteIndexDescriptor AllIndices() => Index(Indices.All);

        // Request parameters
        /// <summary>If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indexes. This behavior applies even if the request targets other open indexes.</summary>
        public DeleteIndexDescriptor AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public DeleteIndexDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`. Valid values are: `all`, `open`, `closed`, `hidden`, `none`.</summary>
        public DeleteIndexDescriptor ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);

        /// <summary>If `false`, the request returns an error if it targets a missing or closed index.</summary>
        public DeleteIndexDescriptor IgnoreUnavailable(bool? ignoreunavailable = true) =>
            Qs("ignore_unavailable", ignoreunavailable);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public DeleteIndexDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);

        /// <summary>Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        public DeleteIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
    }

    /// <summary>Descriptor for DeleteAlias <para>https://opensearch.org/docs/latest/im-plugin/index-alias/#delete-aliases</para></summary>
    public partial class DeleteAliasDescriptor
        : RequestDescriptorBase<
            DeleteAliasDescriptor,
            DeleteAliasRequestParameters,
            IDeleteAliasRequest
        >,
            IDeleteAliasRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesDeleteAlias;

        /// <summary>/{index}/_alias/{name}</summary>
        /// <param name="index">this parameter is required</param>
        /// <param name="name">this parameter is required</param>
        public DeleteAliasDescriptor(Indices index, Names name)
            : base(r => r.Required("index", index).Required("name", name)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected DeleteAliasDescriptor()
            : base() { }

        // values part of the url path
        Indices IDeleteAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
        Names IDeleteAliasRequest.Name => Self.RouteValues.Get<Names>("name");

        /// <summary>Comma-separated list of data streams or indexes used to limit the request. Supports wildcards (`*`).</summary>
        public DeleteAliasDescriptor Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Required("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public DeleteAliasDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public DeleteAliasDescriptor AllIndices() => Index(Indices.All);

        // Request parameters
        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public DeleteAliasDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public DeleteAliasDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);

        /// <summary>Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        public DeleteAliasDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
    }

    /// <summary>Descriptor for DeleteComposableTemplate <para>https://opensearch.org/docs/latest/im-plugin/index-templates/#delete-a-template</para></summary>
    public partial class DeleteComposableIndexTemplateDescriptor
        : RequestDescriptorBase<
            DeleteComposableIndexTemplateDescriptor,
            DeleteComposableIndexTemplateRequestParameters,
            IDeleteComposableIndexTemplateRequest
        >,
            IDeleteComposableIndexTemplateRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesDeleteComposableTemplate;

        /// <summary>/_index_template/{name}</summary>
        /// <param name="name">this parameter is required</param>
        public DeleteComposableIndexTemplateDescriptor(Name name)
            : base(r => r.Required("name", name)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected DeleteComposableIndexTemplateDescriptor()
            : base() { }

        // values part of the url path
        Name IDeleteComposableIndexTemplateRequest.Name => Self.RouteValues.Get<Name>("name");

        // Request parameters
        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public DeleteComposableIndexTemplateDescriptor ClusterManagerTimeout(
            Time clustermanagertimeout
        ) => Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public DeleteComposableIndexTemplateDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);

        /// <summary>Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        public DeleteComposableIndexTemplateDescriptor Timeout(Time timeout) =>
            Qs("timeout", timeout);
    }

    /// <summary>Descriptor for DeleteTemplate <para>https://opensearch.org/docs/latest</para></summary>
    public partial class DeleteIndexTemplateDescriptor
        : RequestDescriptorBase<
            DeleteIndexTemplateDescriptor,
            DeleteIndexTemplateRequestParameters,
            IDeleteIndexTemplateRequest
        >,
            IDeleteIndexTemplateRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesDeleteTemplate;

        /// <summary>/_template/{name}</summary>
        /// <param name="name">this parameter is required</param>
        public DeleteIndexTemplateDescriptor(Name name)
            : base(r => r.Required("name", name)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected DeleteIndexTemplateDescriptor()
            : base() { }

        // values part of the url path
        Name IDeleteIndexTemplateRequest.Name => Self.RouteValues.Get<Name>("name");

        // Request parameters
        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public DeleteIndexTemplateDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public DeleteIndexTemplateDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);

        /// <summary>Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        public DeleteIndexTemplateDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
    }

    /// <summary>Descriptor for Exists <para>https://opensearch.org/docs/latest/api-reference/index-apis/exists/</para></summary>
    public partial class IndexExistsDescriptor
        : RequestDescriptorBase<
            IndexExistsDescriptor,
            IndexExistsRequestParameters,
            IIndexExistsRequest
        >,
            IIndexExistsRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesExists;

        /// <summary>/{index}</summary>
        /// <param name="index">this parameter is required</param>
        public IndexExistsDescriptor(Indices index)
            : base(r => r.Required("index", index)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected IndexExistsDescriptor()
            : base() { }

        // values part of the url path
        Indices IIndexExistsRequest.Index => Self.RouteValues.Get<Indices>("index");

        /// <summary>Comma-separated list of data streams, indexes, and aliases. Supports wildcards (`*`).</summary>
        public IndexExistsDescriptor Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Required("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public IndexExistsDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public IndexExistsDescriptor AllIndices() => Index(Indices.All);

        // Request parameters
        /// <summary>If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indexes. This behavior applies even if the request targets other open indexes.</summary>
        public IndexExistsDescriptor AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public IndexExistsDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`. Valid values are: `all`, `open`, `closed`, `hidden`, `none`.</summary>
        public IndexExistsDescriptor ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);

        /// <summary>If `true`, returns settings in flat format.</summary>
        public IndexExistsDescriptor FlatSettings(bool? flatsettings = true) =>
            Qs("flat_settings", flatsettings);

        /// <summary>If `false`, the request returns an error if it targets a missing or closed index.</summary>
        public IndexExistsDescriptor IgnoreUnavailable(bool? ignoreunavailable = true) =>
            Qs("ignore_unavailable", ignoreunavailable);

        /// <summary>If `true`, return all default settings in the response.</summary>
        public IndexExistsDescriptor IncludeDefaults(bool? includedefaults = true) =>
            Qs("include_defaults", includedefaults);

        /// <summary>If `true`, the request retrieves information from the local node only.</summary>
        public IndexExistsDescriptor Local(bool? local = true) => Qs("local", local);
    }

    /// <summary>Descriptor for AliasExists <para>https://opensearch.org/docs/latest</para></summary>
    public partial class AliasExistsDescriptor
        : RequestDescriptorBase<
            AliasExistsDescriptor,
            AliasExistsRequestParameters,
            IAliasExistsRequest
        >,
            IAliasExistsRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesAliasExists;

        /// <summary>/{index}/_alias/{name}</summary>
        /// <param name="index">Optional, accepts null</param>
        /// <param name="name">this parameter is required</param>
        public AliasExistsDescriptor(Indices index, Names name)
            : base(r => r.Optional("index", index).Required("name", name)) { }

        /// <summary>/_alias/{name}</summary>
        /// <param name="name">this parameter is required</param>
        public AliasExistsDescriptor(Names name)
            : base(r => r.Required("name", name)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected AliasExistsDescriptor()
            : base() { }

        // values part of the url path
        Indices IAliasExistsRequest.Index => Self.RouteValues.Get<Indices>("index");
        Names IAliasExistsRequest.Name => Self.RouteValues.Get<Names>("name");

        /// <summary>Comma-separated list of data streams or indexes used to limit the request. Supports wildcards (`*`). To target all data streams and indexes, omit this parameter or use `*` or `_all`.</summary>
        public AliasExistsDescriptor Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Optional("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public AliasExistsDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public AliasExistsDescriptor AllIndices() => Index(Indices.All);

        // Request parameters
        /// <summary>If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indexes. This behavior applies even if the request targets other open indexes.</summary>
        public AliasExistsDescriptor AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`. Valid values are: `all`, `open`, `closed`, `hidden`, `none`.</summary>
        public AliasExistsDescriptor ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);

        /// <summary>If `false`, requests that include a missing data stream or index in the target indexes or data streams return an error.</summary>
        public AliasExistsDescriptor IgnoreUnavailable(bool? ignoreunavailable = true) =>
            Qs("ignore_unavailable", ignoreunavailable);

        /// <summary>If `true`, the request retrieves information from the local node only.</summary>
        public AliasExistsDescriptor Local(bool? local = true) => Qs("local", local);
    }

    /// <summary>Descriptor for ComposableTemplateExists <para>https://opensearch.org/docs/latest/im-plugin/index-templates/</para></summary>
    public partial class ComposableIndexTemplateExistsDescriptor
        : RequestDescriptorBase<
            ComposableIndexTemplateExistsDescriptor,
            ComposableIndexTemplateExistsRequestParameters,
            IComposableIndexTemplateExistsRequest
        >,
            IComposableIndexTemplateExistsRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesComposableTemplateExists;

        /// <summary>/_index_template/{name}</summary>
        /// <param name="name">this parameter is required</param>
        public ComposableIndexTemplateExistsDescriptor(Name name)
            : base(r => r.Required("name", name)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected ComposableIndexTemplateExistsDescriptor()
            : base() { }

        // values part of the url path
        Name IComposableIndexTemplateExistsRequest.Name => Self.RouteValues.Get<Name>("name");

        // Request parameters
        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public ComposableIndexTemplateExistsDescriptor ClusterManagerTimeout(
            Time clustermanagertimeout
        ) => Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Return settings in flat format.</summary>
        public ComposableIndexTemplateExistsDescriptor FlatSettings(bool? flatsettings = true) =>
            Qs("flat_settings", flatsettings);

        /// <summary>Return local information, do not retrieve the state from cluster-manager node.</summary>
        public ComposableIndexTemplateExistsDescriptor Local(bool? local = true) =>
            Qs("local", local);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public ComposableIndexTemplateExistsDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);
    }

    /// <summary>Descriptor for TemplateExists <para>https://opensearch.org/docs/latest</para></summary>
    public partial class IndexTemplateExistsDescriptor
        : RequestDescriptorBase<
            IndexTemplateExistsDescriptor,
            IndexTemplateExistsRequestParameters,
            IIndexTemplateExistsRequest
        >,
            IIndexTemplateExistsRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesTemplateExists;

        /// <summary>/_template/{name}</summary>
        /// <param name="name">this parameter is required</param>
        public IndexTemplateExistsDescriptor(Names name)
            : base(r => r.Required("name", name)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected IndexTemplateExistsDescriptor()
            : base() { }

        // values part of the url path
        Names IIndexTemplateExistsRequest.Name => Self.RouteValues.Get<Names>("name");

        // Request parameters
        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public IndexTemplateExistsDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Return settings in flat format.</summary>
        public IndexTemplateExistsDescriptor FlatSettings(bool? flatsettings = true) =>
            Qs("flat_settings", flatsettings);

        /// <summary>Return local information, do not retrieve the state from cluster-manager node.</summary>
        public IndexTemplateExistsDescriptor Local(bool? local = true) => Qs("local", local);

        /// <summary>Explicit operation timeout for connection to cluster-manager node.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public IndexTemplateExistsDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);
    }

    /// <summary>Descriptor for Flush <para>https://opensearch.org/docs/latest</para></summary>
    public partial class FlushDescriptor
        : RequestDescriptorBase<FlushDescriptor, FlushRequestParameters, IFlushRequest>,
            IFlushRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesFlush;

        /// <summary>/_flush</summary>
        public FlushDescriptor()
            : base() { }

        /// <summary>/{index}/_flush</summary>
        /// <param name="index">Optional, accepts null</param>
        public FlushDescriptor(Indices index)
            : base(r => r.Optional("index", index)) { }

        // values part of the url path
        Indices IFlushRequest.Index => Self.RouteValues.Get<Indices>("index");

        /// <summary>Comma-separated list of data streams, indexes, and aliases to flush. Supports wildcards (`*`). To flush all data streams and indexes, omit this parameter or use `*` or `_all`.</summary>
        public FlushDescriptor Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Optional("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public FlushDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public FlushDescriptor AllIndices() => Index(Indices.All);

        // Request parameters
        /// <summary>If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indexes. This behavior applies even if the request targets other open indexes.</summary>
        public FlushDescriptor AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`. Valid values are: `all`, `open`, `closed`, `hidden`, `none`.</summary>
        public FlushDescriptor ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);

        /// <summary>If `true`, the request forces a flush even if there are no changes to commit to the index.</summary>
        public FlushDescriptor Force(bool? force = true) => Qs("force", force);

        /// <summary>If `false`, the request returns an error if it targets a missing or closed index.</summary>
        public FlushDescriptor IgnoreUnavailable(bool? ignoreunavailable = true) =>
            Qs("ignore_unavailable", ignoreunavailable);

        /// <summary>If `true`, the flush operation blocks until execution when another flush operation is running. If `false`, OpenSearch returns an error if you request a flush when another flush operation is running.</summary>
        public FlushDescriptor WaitIfOngoing(bool? waitifongoing = true) =>
            Qs("wait_if_ongoing", waitifongoing);
    }

    /// <summary>Descriptor for ForceMerge <para>https://opensearch.org/docs/latest</para></summary>
    public partial class ForceMergeDescriptor
        : RequestDescriptorBase<
            ForceMergeDescriptor,
            ForceMergeRequestParameters,
            IForceMergeRequest
        >,
            IForceMergeRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesForceMerge;

        /// <summary>/_forcemerge</summary>
        public ForceMergeDescriptor()
            : base() { }

        /// <summary>/{index}/_forcemerge</summary>
        /// <param name="index">Optional, accepts null</param>
        public ForceMergeDescriptor(Indices index)
            : base(r => r.Optional("index", index)) { }

        // values part of the url path
        Indices IForceMergeRequest.Index => Self.RouteValues.Get<Indices>("index");

        /// <summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indexes.</summary>
        public ForceMergeDescriptor Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Optional("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public ForceMergeDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public ForceMergeDescriptor AllIndices() => Index(Indices.All);

        // Request parameters
        /// <summary>Whether to ignore if a wildcard indexes expression resolves into no concrete indexes. (This includes `_all` string or when no indexes have been specified).</summary>
        public ForceMergeDescriptor AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>Whether to expand wildcard expression to concrete indexes that are open, closed or both.</summary>
        public ForceMergeDescriptor ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);

        /// <summary>Specify whether the index should be flushed after performing the operation.</summary>
        public ForceMergeDescriptor Flush(bool? flush = true) => Qs("flush", flush);

        /// <summary>Whether specified concrete indexes should be ignored when unavailable (missing or closed).</summary>
        public ForceMergeDescriptor IgnoreUnavailable(bool? ignoreunavailable = true) =>
            Qs("ignore_unavailable", ignoreunavailable);

        /// <summary>The number of larger segments into which smaller segments are merged. Set this parameter to 1 to merge all segments into one segment. The default behavior is to perform the merge as necessary.</summary>
        public ForceMergeDescriptor MaxNumSegments(long? maxnumsegments) =>
            Qs("max_num_segments", maxnumsegments);

        /// <summary>Specify whether the operation should only expunge deleted documents.</summary>
        public ForceMergeDescriptor OnlyExpungeDeletes(bool? onlyexpungedeletes = true) =>
            Qs("only_expunge_deletes", onlyexpungedeletes);

        /// <summary>Specify whether the operation should only perform on primary shards. Defaults to false.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.13.0 or greater.</remarks>
        public ForceMergeDescriptor PrimaryOnly(bool? primaryonly = true) =>
            Qs("primary_only", primaryonly);

        /// <summary>Should the request wait until the force merge is completed.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.7.0 or greater.</remarks>
        public ForceMergeDescriptor WaitForCompletion(bool? waitforcompletion = true) =>
            Qs("wait_for_completion", waitforcompletion);
    }

    /// <summary>Descriptor for Get <para>https://opensearch.org/docs/latest/api-reference/index-apis/get-index/</para></summary>
    public partial class GetIndexDescriptor
        : RequestDescriptorBase<GetIndexDescriptor, GetIndexRequestParameters, IGetIndexRequest>,
            IGetIndexRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesGet;

        /// <summary>/{index}</summary>
        /// <param name="index">this parameter is required</param>
        public GetIndexDescriptor(Indices index)
            : base(r => r.Required("index", index)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected GetIndexDescriptor()
            : base() { }

        // values part of the url path
        Indices IGetIndexRequest.Index => Self.RouteValues.Get<Indices>("index");

        /// <summary>Comma-separated list of data streams, indexes, and index aliases used to limit the request. Wildcard expressions (*) are supported.</summary>
        public GetIndexDescriptor Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Required("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public GetIndexDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public GetIndexDescriptor AllIndices() => Index(Indices.All);

        // Request parameters
        /// <summary>If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indexes. This behavior applies even if the request targets other open indexes. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.</summary>
        public GetIndexDescriptor AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public GetIndexDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Type of index that wildcard expressions can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`.</summary>
        public GetIndexDescriptor ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);

        /// <summary>If `true`, returns settings in flat format.</summary>
        public GetIndexDescriptor FlatSettings(bool? flatsettings = true) =>
            Qs("flat_settings", flatsettings);

        /// <summary>If `false`, requests that target a missing index return an error.</summary>
        public GetIndexDescriptor IgnoreUnavailable(bool? ignoreunavailable = true) =>
            Qs("ignore_unavailable", ignoreunavailable);

        /// <summary>If `true`, return all default settings in the response.</summary>
        public GetIndexDescriptor IncludeDefaults(bool? includedefaults = true) =>
            Qs("include_defaults", includedefaults);

        /// <summary>If `true`, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the cluster-manager node.</summary>
        public GetIndexDescriptor Local(bool? local = true) => Qs("local", local);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public GetIndexDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);
    }

    /// <summary>Descriptor for GetAlias <para>https://opensearch.org/docs/latest/im-plugin/index-alias/</para></summary>
    public partial class GetAliasDescriptor
        : RequestDescriptorBase<GetAliasDescriptor, GetAliasRequestParameters, IGetAliasRequest>,
            IGetAliasRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesGetAlias;

        /// <summary>/_alias</summary>
        public GetAliasDescriptor()
            : base() { }

        /// <summary>/{index}/_alias</summary>
        /// <param name="index">Optional, accepts null</param>
        public GetAliasDescriptor(Indices index)
            : base(r => r.Optional("index", index)) { }

        /// <summary>/{index}/_alias/{name}</summary>
        /// <param name="index">Optional, accepts null</param>
        /// <param name="name">Optional, accepts null</param>
        public GetAliasDescriptor(Indices index, Names name)
            : base(r => r.Optional("index", index).Optional("name", name)) { }

        /// <summary>/_alias/{name}</summary>
        /// <param name="name">Optional, accepts null</param>
        public GetAliasDescriptor(Names name)
            : base(r => r.Optional("name", name)) { }

        // values part of the url path
        Indices IGetAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
        Names IGetAliasRequest.Name => Self.RouteValues.Get<Names>("name");

        /// <summary>Comma-separated list of data streams or indexes used to limit the request. Supports wildcards (`*`). To target all data streams and indexes, omit this parameter or use `*` or `_all`.</summary>
        public GetAliasDescriptor Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Optional("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public GetAliasDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public GetAliasDescriptor AllIndices() => Index(Indices.All);

        /// <summary>Comma-separated list of aliases to retrieve. Supports wildcards (`*`). To retrieve all aliases, omit this parameter or use `*` or `_all`.</summary>
        public GetAliasDescriptor Name(Names name) =>
            Assign(name, (a, v) => a.RouteValues.Optional("name", v));

        // Request parameters
        /// <summary>If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indexes. This behavior applies even if the request targets other open indexes.</summary>
        public GetAliasDescriptor AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`. Valid values are: `all`, `open`, `closed`, `hidden`, `none`.</summary>
        public GetAliasDescriptor ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);

        /// <summary>If `false`, the request returns an error if it targets a missing or closed index.</summary>
        public GetAliasDescriptor IgnoreUnavailable(bool? ignoreunavailable = true) =>
            Qs("ignore_unavailable", ignoreunavailable);

        /// <summary>If `true`, the request retrieves information from the local node only.</summary>
        public GetAliasDescriptor Local(bool? local = true) => Qs("local", local);
    }

    /// <summary>Descriptor for GetFieldMapping <para>https://opensearch.org/docs/latest/field-types/index/</para></summary>
    public partial class GetFieldMappingDescriptor<TDocument>
        : RequestDescriptorBase<
            GetFieldMappingDescriptor<TDocument>,
            GetFieldMappingRequestParameters,
            IGetFieldMappingRequest
        >,
            IGetFieldMappingRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesGetFieldMapping;

        /// <summary>/{index}/_mapping/field/{fields}</summary>
        /// <param name="fields">this parameter is required</param>
        public GetFieldMappingDescriptor(Fields fields)
            : this(typeof(TDocument), fields) { }

        /// <summary>/{index}/_mapping/field/{fields}</summary>
        /// <param name="index">Optional, accepts null</param>
        /// <param name="fields">this parameter is required</param>
        public GetFieldMappingDescriptor(Indices index, Fields fields)
            : base(r => r.Optional("index", index).Required("fields", fields)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected GetFieldMappingDescriptor()
            : base() { }

        // values part of the url path
        Fields IGetFieldMappingRequest.Fields => Self.RouteValues.Get<Fields>("fields");
        Indices IGetFieldMappingRequest.Index => Self.RouteValues.Get<Indices>("index");

        /// <summary>Comma-separated list of data streams, indexes, and aliases used to limit the request. Supports wildcards (`*`). To target all data streams and indexes, omit this parameter or use `*` or `_all`.</summary>
        public GetFieldMappingDescriptor<TDocument> Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Optional("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public GetFieldMappingDescriptor<TDocument> Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public GetFieldMappingDescriptor<TDocument> AllIndices() => Index(Indices.All);

        // Request parameters
        /// <summary>If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indexes. This behavior applies even if the request targets other open indexes.</summary>
        public GetFieldMappingDescriptor<TDocument> AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`. Valid values are: `all`, `open`, `closed`, `hidden`, `none`.</summary>
        public GetFieldMappingDescriptor<TDocument> ExpandWildcards(
            ExpandWildcards? expandwildcards
        ) => Qs("expand_wildcards", expandwildcards);

        /// <summary>If `false`, the request returns an error if it targets a missing or closed index.</summary>
        public GetFieldMappingDescriptor<TDocument> IgnoreUnavailable(
            bool? ignoreunavailable = true
        ) => Qs("ignore_unavailable", ignoreunavailable);

        /// <summary>If `true`, return all default settings in the response.</summary>
        public GetFieldMappingDescriptor<TDocument> IncludeDefaults(bool? includedefaults = true) =>
            Qs("include_defaults", includedefaults);

        /// <summary>If `true`, the request retrieves information from the local node only.</summary>
        public GetFieldMappingDescriptor<TDocument> Local(bool? local = true) => Qs("local", local);
    }

    /// <summary>Descriptor for GetComposableTemplate <para>https://opensearch.org/docs/latest/im-plugin/index-templates/</para></summary>
    public partial class GetComposableIndexTemplateDescriptor
        : RequestDescriptorBase<
            GetComposableIndexTemplateDescriptor,
            GetComposableIndexTemplateRequestParameters,
            IGetComposableIndexTemplateRequest
        >,
            IGetComposableIndexTemplateRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesGetComposableTemplate;

        /// <summary>/_index_template</summary>
        public GetComposableIndexTemplateDescriptor()
            : base() { }

        /// <summary>/_index_template/{name}</summary>
        /// <param name="name">Optional, accepts null</param>
        public GetComposableIndexTemplateDescriptor(Name name)
            : base(r => r.Optional("name", name)) { }

        // values part of the url path
        Name IGetComposableIndexTemplateRequest.Name => Self.RouteValues.Get<Name>("name");

        /// <summary>Name of the index template to retrieve. Wildcard (*) expressions are supported.</summary>
        public GetComposableIndexTemplateDescriptor Name(Name name) =>
            Assign(name, (a, v) => a.RouteValues.Optional("name", v));

        // Request parameters
        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public GetComposableIndexTemplateDescriptor ClusterManagerTimeout(
            Time clustermanagertimeout
        ) => Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>If `true`, returns settings in flat format.</summary>
        public GetComposableIndexTemplateDescriptor FlatSettings(bool? flatsettings = true) =>
            Qs("flat_settings", flatsettings);

        /// <summary>If `true`, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the cluster-manager node.</summary>
        public GetComposableIndexTemplateDescriptor Local(bool? local = true) => Qs("local", local);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public GetComposableIndexTemplateDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);
    }

    /// <summary>Descriptor for GetMapping <para>https://opensearch.org/docs/latest/field-types/index/#get-a-mapping</para></summary>
    public partial class GetMappingDescriptor<TDocument>
        : RequestDescriptorBase<
            GetMappingDescriptor<TDocument>,
            GetMappingRequestParameters,
            IGetMappingRequest
        >,
            IGetMappingRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesGetMapping;

        /// <summary>/{index}/_mapping</summary>
        public GetMappingDescriptor()
            : this(typeof(TDocument)) { }

        /// <summary>/{index}/_mapping</summary>
        /// <param name="index">Optional, accepts null</param>
        public GetMappingDescriptor(Indices index)
            : base(r => r.Optional("index", index)) { }

        // values part of the url path
        Indices IGetMappingRequest.Index => Self.RouteValues.Get<Indices>("index");

        /// <summary>Comma-separated list of data streams, indexes, and aliases used to limit the request. Supports wildcards (`*`). To target all data streams and indexes, omit this parameter or use `*` or `_all`.</summary>
        public GetMappingDescriptor<TDocument> Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Optional("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public GetMappingDescriptor<TDocument> Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public GetMappingDescriptor<TDocument> AllIndices() => Index(Indices.All);

        // Request parameters
        /// <summary>If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indexes. This behavior applies even if the request targets other open indexes.</summary>
        public GetMappingDescriptor<TDocument> AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public GetMappingDescriptor<TDocument> ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`. Valid values are: `all`, `open`, `closed`, `hidden`, `none`.</summary>
        public GetMappingDescriptor<TDocument> ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);

        /// <summary>If `false`, the request returns an error if it targets a missing or closed index.</summary>
        public GetMappingDescriptor<TDocument> IgnoreUnavailable(bool? ignoreunavailable = true) =>
            Qs("ignore_unavailable", ignoreunavailable);

        /// <summary>If `true`, the request retrieves information from the local node only.</summary>
        public GetMappingDescriptor<TDocument> Local(bool? local = true) => Qs("local", local);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public GetMappingDescriptor<TDocument> MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);
    }

    /// <summary>Descriptor for GetSettings <para>https://opensearch.org/docs/latest/api-reference/index-apis/get-settings/</para></summary>
    public partial class GetIndexSettingsDescriptor
        : RequestDescriptorBase<
            GetIndexSettingsDescriptor,
            GetIndexSettingsRequestParameters,
            IGetIndexSettingsRequest
        >,
            IGetIndexSettingsRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesGetSettings;

        /// <summary>/_settings</summary>
        public GetIndexSettingsDescriptor()
            : base() { }

        /// <summary>/{index}/_settings</summary>
        /// <param name="index">Optional, accepts null</param>
        public GetIndexSettingsDescriptor(Indices index)
            : base(r => r.Optional("index", index)) { }

        /// <summary>/{index}/_settings/{name}</summary>
        /// <param name="index">Optional, accepts null</param>
        /// <param name="name">Optional, accepts null</param>
        public GetIndexSettingsDescriptor(Indices index, Names name)
            : base(r => r.Optional("index", index).Optional("name", name)) { }

        /// <summary>/_settings/{name}</summary>
        /// <param name="name">Optional, accepts null</param>
        public GetIndexSettingsDescriptor(Names name)
            : base(r => r.Optional("name", name)) { }

        // values part of the url path
        Indices IGetIndexSettingsRequest.Index => Self.RouteValues.Get<Indices>("index");
        Names IGetIndexSettingsRequest.Name => Self.RouteValues.Get<Names>("name");

        /// <summary>Comma-separated list of data streams, indexes, and aliases used to limit the request. Supports wildcards (`*`). To target all data streams and indexes, omit this parameter or use `*` or `_all`.</summary>
        public GetIndexSettingsDescriptor Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Optional("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public GetIndexSettingsDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public GetIndexSettingsDescriptor AllIndices() => Index(Indices.All);

        /// <summary>Comma-separated list or wildcard expression of settings to retrieve.</summary>
        public GetIndexSettingsDescriptor Name(Names name) =>
            Assign(name, (a, v) => a.RouteValues.Optional("name", v));

        // Request parameters
        /// <summary>If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indexes. This behavior applies even if the request targets other open indexes. For example, a request targeting `foo*,bar*` returns an error if an index starts with foo but no index starts with `bar`.</summary>
        public GetIndexSettingsDescriptor AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public GetIndexSettingsDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`.</summary>
        public GetIndexSettingsDescriptor ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);

        /// <summary>If `true`, returns settings in flat format.</summary>
        public GetIndexSettingsDescriptor FlatSettings(bool? flatsettings = true) =>
            Qs("flat_settings", flatsettings);

        /// <summary>If `false`, the request returns an error if it targets a missing or closed index.</summary>
        public GetIndexSettingsDescriptor IgnoreUnavailable(bool? ignoreunavailable = true) =>
            Qs("ignore_unavailable", ignoreunavailable);

        /// <summary>If `true`, return all default settings in the response.</summary>
        public GetIndexSettingsDescriptor IncludeDefaults(bool? includedefaults = true) =>
            Qs("include_defaults", includedefaults);

        /// <summary>If `true`, the request retrieves information from the local node only. If `false`, information is retrieved from the cluster-manager node.</summary>
        public GetIndexSettingsDescriptor Local(bool? local = true) => Qs("local", local);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public GetIndexSettingsDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);
    }

    /// <summary>Descriptor for GetTemplate <para>https://opensearch.org/docs/latest</para></summary>
    public partial class GetIndexTemplateDescriptor
        : RequestDescriptorBase<
            GetIndexTemplateDescriptor,
            GetIndexTemplateRequestParameters,
            IGetIndexTemplateRequest
        >,
            IGetIndexTemplateRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesGetTemplate;

        /// <summary>/_template</summary>
        public GetIndexTemplateDescriptor()
            : base() { }

        /// <summary>/_template/{name}</summary>
        /// <param name="name">Optional, accepts null</param>
        public GetIndexTemplateDescriptor(Names name)
            : base(r => r.Optional("name", name)) { }

        // values part of the url path
        Names IGetIndexTemplateRequest.Name => Self.RouteValues.Get<Names>("name");

        /// <summary>Comma-separated list of index template names used to limit the request. Wildcard (`*`) expressions are supported. To return all index templates, omit this parameter or use a value of `_all` or `*`.</summary>
        public GetIndexTemplateDescriptor Name(Names name) =>
            Assign(name, (a, v) => a.RouteValues.Optional("name", v));

        // Request parameters
        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public GetIndexTemplateDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>If `true`, returns settings in flat format.</summary>
        public GetIndexTemplateDescriptor FlatSettings(bool? flatsettings = true) =>
            Qs("flat_settings", flatsettings);

        /// <summary>If `true`, the request retrieves information from the local node only.</summary>
        public GetIndexTemplateDescriptor Local(bool? local = true) => Qs("local", local);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public GetIndexTemplateDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);
    }

    /// <summary>Descriptor for Open <para>https://opensearch.org/docs/latest/api-reference/index-apis/open-index/</para></summary>
    public partial class OpenIndexDescriptor
        : RequestDescriptorBase<OpenIndexDescriptor, OpenIndexRequestParameters, IOpenIndexRequest>,
            IOpenIndexRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesOpen;

        /// <summary>/{index}/_open</summary>
        /// <param name="index">this parameter is required</param>
        public OpenIndexDescriptor(Indices index)
            : base(r => r.Required("index", index)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected OpenIndexDescriptor()
            : base() { }

        // values part of the url path
        Indices IOpenIndexRequest.Index => Self.RouteValues.Get<Indices>("index");

        /// <summary>Comma-separated list of data streams, indexes, and aliases used to limit the request. Supports wildcards (`*`). By default, you must explicitly name the indexes you using to limit the request. To limit a request using `_all`, `*`, or other wildcard expressions, change the `action.destructive_requires_name` setting to false. You can update this setting in the `opensearch.yml` file or using the cluster update settings API.</summary>
        public OpenIndexDescriptor Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Required("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public OpenIndexDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public OpenIndexDescriptor AllIndices() => Index(Indices.All);

        // Request parameters
        /// <summary>If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indexes. This behavior applies even if the request targets other open indexes.</summary>
        public OpenIndexDescriptor AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public OpenIndexDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`. Valid values are: `all`, `open`, `closed`, `hidden`, `none`.</summary>
        public OpenIndexDescriptor ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);

        /// <summary>If `false`, the request returns an error if it targets a missing or closed index.</summary>
        public OpenIndexDescriptor IgnoreUnavailable(bool? ignoreunavailable = true) =>
            Qs("ignore_unavailable", ignoreunavailable);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public OpenIndexDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);

        /// <summary>Explicit task execution timeout, only useful when `wait_for_completion` is false, defaults to `1h`.</summary>
        public OpenIndexDescriptor TaskExecutionTimeout(Time taskexecutiontimeout) =>
            Qs("task_execution_timeout", taskexecutiontimeout);

        /// <summary>Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        public OpenIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);

        /// <summary>The number of shard copies that must be active before proceeding with the operation. Set to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).</summary>
        public OpenIndexDescriptor WaitForActiveShards(string waitforactiveshards) =>
            Qs("wait_for_active_shards", waitforactiveshards);

        /// <summary>Should this request wait until the operation has completed before returning.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.7.0 or greater.</remarks>
        public OpenIndexDescriptor WaitForCompletion(bool? waitforcompletion = true) =>
            Qs("wait_for_completion", waitforcompletion);
    }

    /// <summary>Descriptor for PutAlias <para>https://opensearch.org/docs/latest/api-reference/index-apis/update-alias/</para></summary>
    public partial class PutAliasDescriptor
        : RequestDescriptorBase<PutAliasDescriptor, PutAliasRequestParameters, IPutAliasRequest>,
            IPutAliasRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesPutAlias;

        /// <summary>/_alias</summary>
        public PutAliasDescriptor()
            : base() { }

        /// <summary>/{index}/_alias</summary>
        /// <param name="index">Optional, accepts null</param>
        public PutAliasDescriptor(Indices index)
            : base(r => r.Optional("index", index)) { }

        /// <summary>/{index}/_alias/{name}</summary>
        /// <param name="index">Optional, accepts null</param>
        /// <param name="name">Optional, accepts null</param>
        public PutAliasDescriptor(Indices index, Name name)
            : base(r => r.Optional("index", index).Optional("name", name)) { }

        /// <summary>/_alias/{name}</summary>
        /// <param name="name">Optional, accepts null</param>
        public PutAliasDescriptor(Name name)
            : base(r => r.Optional("name", name)) { }

        // values part of the url path
        Indices IPutAliasRequest.Index => Self.RouteValues.Get<Indices>("index");
        Name IPutAliasRequest.Name => Self.RouteValues.Get<Name>("name");

        /// <summary>Comma-separated list of data streams or indexes to add. Supports wildcards (`*`). Wildcard patterns that match both data streams and indexes return an error.</summary>
        public PutAliasDescriptor Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Optional("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public PutAliasDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public PutAliasDescriptor AllIndices() => Index(Indices.All);

        /// <summary>Alias to update. If the alias doesn't exist, the request creates it. Index alias names support date math.</summary>
        public PutAliasDescriptor Name(Name name) =>
            Assign(name, (a, v) => a.RouteValues.Optional("name", v));

        // Request parameters
        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public PutAliasDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public PutAliasDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);

        /// <summary>Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        public PutAliasDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
    }

    /// <summary>Descriptor for PutComposableTemplate <para>https://opensearch.org/docs/latest/im-plugin/index-templates/</para></summary>
    public partial class PutComposableIndexTemplateDescriptor
        : RequestDescriptorBase<
            PutComposableIndexTemplateDescriptor,
            PutComposableIndexTemplateRequestParameters,
            IPutComposableIndexTemplateRequest
        >,
            IPutComposableIndexTemplateRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesPutComposableTemplate;

        /// <summary>/_index_template/{name}</summary>
        /// <param name="name">this parameter is required</param>
        public PutComposableIndexTemplateDescriptor(Name name)
            : base(r => r.Required("name", name)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected PutComposableIndexTemplateDescriptor()
            : base() { }

        // values part of the url path
        Name IPutComposableIndexTemplateRequest.Name => Self.RouteValues.Get<Name>("name");

        // Request parameters
        /// <summary>User defined reason for creating/updating the index template.</summary>
        public PutComposableIndexTemplateDescriptor Cause(string cause) => Qs("cause", cause);

        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public PutComposableIndexTemplateDescriptor ClusterManagerTimeout(
            Time clustermanagertimeout
        ) => Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>If `true`, this request cannot replace or update existing index templates.</summary>
        public PutComposableIndexTemplateDescriptor Create(bool? create = true) =>
            Qs("create", create);

        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public PutComposableIndexTemplateDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);
    }

    /// <summary>Descriptor for PutMapping <para>https://opensearch.org/docs/latest/api-reference/index-apis/put-mapping/</para></summary>
    public partial class PutMappingDescriptor<TDocument>
        : RequestDescriptorBase<
            PutMappingDescriptor<TDocument>,
            PutMappingRequestParameters,
            IPutMappingRequest<TDocument>
        >,
            IPutMappingRequest<TDocument>
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesPutMapping;

        /// <summary>/{index}/_mapping</summary>
        /// <param name="index">this parameter is required</param>
        public PutMappingDescriptor(Indices index)
            : base(r => r.Required("index", index)) { }

        /// <summary>/{index}/_mapping</summary>
        public PutMappingDescriptor()
            : this(typeof(TDocument)) { }

        // values part of the url path
        Indices IPutMappingRequest.Index => Self.RouteValues.Get<Indices>("index");

        /// <summary>A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indexes.</summary>
        public PutMappingDescriptor<TDocument> Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Required("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public PutMappingDescriptor<TDocument> Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public PutMappingDescriptor<TDocument> AllIndices() => Index(Indices.All);

        // Request parameters
        /// <summary>If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indexes. This behavior applies even if the request targets other open indexes.</summary>
        public PutMappingDescriptor<TDocument> AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public PutMappingDescriptor<TDocument> ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`. Valid values are: `all`, `open`, `closed`, `hidden`, `none`.</summary>
        public PutMappingDescriptor<TDocument> ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);

        /// <summary>If `false`, the request returns an error if it targets a missing or closed index.</summary>
        public PutMappingDescriptor<TDocument> IgnoreUnavailable(bool? ignoreunavailable = true) =>
            Qs("ignore_unavailable", ignoreunavailable);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public PutMappingDescriptor<TDocument> MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);

        /// <summary>Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        public PutMappingDescriptor<TDocument> Timeout(Time timeout) => Qs("timeout", timeout);

        /// <summary>If `true`, the mappings are applied only to the current write index for the target.</summary>
        public PutMappingDescriptor<TDocument> WriteIndexOnly(bool? writeindexonly = true) =>
            Qs("write_index_only", writeindexonly);
    }

    /// <summary>Descriptor for UpdateSettings <para>https://opensearch.org/docs/latest/api-reference/index-apis/update-settings/</para></summary>
    public partial class UpdateIndexSettingsDescriptor
        : RequestDescriptorBase<
            UpdateIndexSettingsDescriptor,
            UpdateIndexSettingsRequestParameters,
            IUpdateIndexSettingsRequest
        >,
            IUpdateIndexSettingsRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesUpdateSettings;

        /// <summary>/_settings</summary>
        public UpdateIndexSettingsDescriptor()
            : base() { }

        /// <summary>/{index}/_settings</summary>
        /// <param name="index">Optional, accepts null</param>
        public UpdateIndexSettingsDescriptor(Indices index)
            : base(r => r.Optional("index", index)) { }

        // values part of the url path
        Indices IUpdateIndexSettingsRequest.Index => Self.RouteValues.Get<Indices>("index");

        /// <summary>Comma-separated list of data streams, indexes, and aliases used to limit the request. Supports wildcards (`*`). To target all data streams and indexes, omit this parameter or use `*` or `_all`.</summary>
        public UpdateIndexSettingsDescriptor Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Optional("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public UpdateIndexSettingsDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public UpdateIndexSettingsDescriptor AllIndices() => Index(Indices.All);

        // Request parameters
        /// <summary>If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indexes. This behavior applies even if the request targets other open indexes. For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.</summary>
        public UpdateIndexSettingsDescriptor AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public UpdateIndexSettingsDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`.</summary>
        public UpdateIndexSettingsDescriptor ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);

        /// <summary>If `true`, returns settings in flat format.</summary>
        public UpdateIndexSettingsDescriptor FlatSettings(bool? flatsettings = true) =>
            Qs("flat_settings", flatsettings);

        /// <summary>Whether specified concrete indexes should be ignored when unavailable (missing or closed).</summary>
        public UpdateIndexSettingsDescriptor IgnoreUnavailable(bool? ignoreunavailable = true) =>
            Qs("ignore_unavailable", ignoreunavailable);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public UpdateIndexSettingsDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);

        /// <summary>If `true`, existing index settings remain unchanged.</summary>
        public UpdateIndexSettingsDescriptor PreserveExisting(bool? preserveexisting = true) =>
            Qs("preserve_existing", preserveexisting);

        /// <summary>Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        public UpdateIndexSettingsDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
    }

    /// <summary>Descriptor for PutTemplate <para>https://opensearch.org/docs/latest/im-plugin/index-templates/</para></summary>
    public partial class PutIndexTemplateDescriptor
        : RequestDescriptorBase<
            PutIndexTemplateDescriptor,
            PutIndexTemplateRequestParameters,
            IPutIndexTemplateRequest
        >,
            IPutIndexTemplateRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesPutTemplate;

        /// <summary>/_template/{name}</summary>
        /// <param name="name">this parameter is required</param>
        public PutIndexTemplateDescriptor(Name name)
            : base(r => r.Required("name", name)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected PutIndexTemplateDescriptor()
            : base() { }

        // values part of the url path
        Name IPutIndexTemplateRequest.Name => Self.RouteValues.Get<Name>("name");

        // Request parameters
        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public PutIndexTemplateDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>If `true`, this request cannot replace or update existing index templates.</summary>
        public PutIndexTemplateDescriptor Create(bool? create = true) => Qs("create", create);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public PutIndexTemplateDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);
    }

    /// <summary>Descriptor for Refresh <para>https://opensearch.org/docs/latest/tuning-your-cluster/availability-and-recovery/remote-store/index/#refresh-level-and-request-level-durability</para></summary>
    public partial class RefreshDescriptor
        : RequestDescriptorBase<RefreshDescriptor, RefreshRequestParameters, IRefreshRequest>,
            IRefreshRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesRefresh;

        /// <summary>/_refresh</summary>
        public RefreshDescriptor()
            : base() { }

        /// <summary>/{index}/_refresh</summary>
        /// <param name="index">Optional, accepts null</param>
        public RefreshDescriptor(Indices index)
            : base(r => r.Optional("index", index)) { }

        // values part of the url path
        Indices IRefreshRequest.Index => Self.RouteValues.Get<Indices>("index");

        /// <summary>Comma-separated list of data streams, indexes, and aliases used to limit the request. Supports wildcards (`*`). To target all data streams and indexes, omit this parameter or use `*` or `_all`.</summary>
        public RefreshDescriptor Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Optional("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public RefreshDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public RefreshDescriptor AllIndices() => Index(Indices.All);

        // Request parameters
        /// <summary>If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indexes. This behavior applies even if the request targets other open indexes.</summary>
        public RefreshDescriptor AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`. Valid values are: `all`, `open`, `closed`, `hidden`, `none`.</summary>
        public RefreshDescriptor ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);

        /// <summary>If `false`, the request returns an error if it targets a missing or closed index.</summary>
        public RefreshDescriptor IgnoreUnavailable(bool? ignoreunavailable = true) =>
            Qs("ignore_unavailable", ignoreunavailable);
    }

    /// <summary>Descriptor for Resolve <para>https://opensearch.org/docs/latest</para></summary>
    public partial class ResolveIndexDescriptor
        : RequestDescriptorBase<
            ResolveIndexDescriptor,
            ResolveIndexRequestParameters,
            IResolveIndexRequest
        >,
            IResolveIndexRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesResolve;

        /// <summary>/_resolve/index/{name}</summary>
        /// <param name="name">this parameter is required</param>
        public ResolveIndexDescriptor(Names name)
            : base(r => r.Required("name", name)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected ResolveIndexDescriptor()
            : base() { }

        // values part of the url path
        Names IResolveIndexRequest.Name => Self.RouteValues.Get<Names>("name");

        // Request parameters
        /// <summary>Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`. Valid values are: `all`, `open`, `closed`, `hidden`, `none`.</summary>
        public ResolveIndexDescriptor ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);
    }

    /// <summary>Descriptor for Rollover <para>https://opensearch.org/docs/latest/dashboards/im-dashboards/rollover/</para></summary>
    public partial class RolloverIndexDescriptor
        : RequestDescriptorBase<
            RolloverIndexDescriptor,
            RolloverIndexRequestParameters,
            IRolloverIndexRequest
        >,
            IRolloverIndexRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesRollover;

        /// <summary>/{alias}/_rollover</summary>
        /// <param name="alias">this parameter is required</param>
        public RolloverIndexDescriptor(Name alias)
            : base(r => r.Required("alias", alias)) { }

        /// <summary>/{alias}/_rollover/{new_index}</summary>
        /// <param name="alias">this parameter is required</param>
        /// <param name="newIndex">Optional, accepts null</param>
        public RolloverIndexDescriptor(Name alias, IndexName newIndex)
            : base(r => r.Required("alias", alias).Optional("new_index", newIndex)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected RolloverIndexDescriptor()
            : base() { }

        // values part of the url path
        Name IRolloverIndexRequest.Alias => Self.RouteValues.Get<Name>("alias");
        IndexName IRolloverIndexRequest.NewIndex => Self.RouteValues.Get<IndexName>("new_index");

        /// <summary>Name of the index to create. Supports date math. Data streams do not support this parameter.</summary>
        public RolloverIndexDescriptor NewIndex(IndexName newIndex) =>
            Assign(newIndex, (a, v) => a.RouteValues.Optional("new_index", v));

        // Request parameters
        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public RolloverIndexDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>If `true`, checks whether the current index satisfies the specified conditions but does not perform a rollover.</summary>
        public RolloverIndexDescriptor DryRun(bool? dryrun = true) => Qs("dry_run", dryrun);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public RolloverIndexDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);

        /// <summary>Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        public RolloverIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);

        /// <summary>The number of shard copies that must be active before proceeding with the operation. Set to all or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).</summary>
        public RolloverIndexDescriptor WaitForActiveShards(string waitforactiveshards) =>
            Qs("wait_for_active_shards", waitforactiveshards);
    }

    /// <summary>Descriptor for Shrink <para>https://opensearch.org/docs/latest/api-reference/index-apis/shrink-index/</para></summary>
    public partial class ShrinkIndexDescriptor
        : RequestDescriptorBase<
            ShrinkIndexDescriptor,
            ShrinkIndexRequestParameters,
            IShrinkIndexRequest
        >,
            IShrinkIndexRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesShrink;

        /// <summary>/{index}/_shrink/{target}</summary>
        /// <param name="index">this parameter is required</param>
        /// <param name="target">this parameter is required</param>
        public ShrinkIndexDescriptor(IndexName index, IndexName target)
            : base(r => r.Required("index", index).Required("target", target)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected ShrinkIndexDescriptor()
            : base() { }

        // values part of the url path
        IndexName IShrinkIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
        IndexName IShrinkIndexRequest.Target => Self.RouteValues.Get<IndexName>("target");

        /// <summary>Name of the source index to shrink.</summary>
        public ShrinkIndexDescriptor Index(IndexName index) =>
            Assign(index, (a, v) => a.RouteValues.Required("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public ShrinkIndexDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));

        // Request parameters
        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public ShrinkIndexDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public ShrinkIndexDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);

        /// <summary>Explicit task execution timeout, only useful when `wait_for_completion` is false, defaults to `1h`.</summary>
        public ShrinkIndexDescriptor TaskExecutionTimeout(Time taskexecutiontimeout) =>
            Qs("task_execution_timeout", taskexecutiontimeout);

        /// <summary>Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        public ShrinkIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);

        /// <summary>The number of shard copies that must be active before proceeding with the operation. Set to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).</summary>
        public ShrinkIndexDescriptor WaitForActiveShards(string waitforactiveshards) =>
            Qs("wait_for_active_shards", waitforactiveshards);

        /// <summary>Should this request wait until the operation has completed before returning.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.7.0 or greater.</remarks>
        public ShrinkIndexDescriptor WaitForCompletion(bool? waitforcompletion = true) =>
            Qs("wait_for_completion", waitforcompletion);
    }

    /// <summary>Descriptor for Split <para>https://opensearch.org/docs/latest/api-reference/index-apis/split/</para></summary>
    public partial class SplitIndexDescriptor
        : RequestDescriptorBase<
            SplitIndexDescriptor,
            SplitIndexRequestParameters,
            ISplitIndexRequest
        >,
            ISplitIndexRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesSplit;

        /// <summary>/{index}/_split/{target}</summary>
        /// <param name="index">this parameter is required</param>
        /// <param name="target">this parameter is required</param>
        public SplitIndexDescriptor(IndexName index, IndexName target)
            : base(r => r.Required("index", index).Required("target", target)) { }

        /// <summary>Used for serialization purposes, making sure we have a parameterless constructor</summary>
        [SerializationConstructor]
        protected SplitIndexDescriptor()
            : base() { }

        // values part of the url path
        IndexName ISplitIndexRequest.Index => Self.RouteValues.Get<IndexName>("index");
        IndexName ISplitIndexRequest.Target => Self.RouteValues.Get<IndexName>("target");

        /// <summary>Name of the source index to split.</summary>
        public SplitIndexDescriptor Index(IndexName index) =>
            Assign(index, (a, v) => a.RouteValues.Required("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public SplitIndexDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Required("index", (IndexName)v));

        // Request parameters
        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public SplitIndexDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public SplitIndexDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);

        /// <summary>Explicit task execution timeout, only useful when `wait_for_completion` is false, defaults to `1h`.</summary>
        public SplitIndexDescriptor TaskExecutionTimeout(Time taskexecutiontimeout) =>
            Qs("task_execution_timeout", taskexecutiontimeout);

        /// <summary>Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        public SplitIndexDescriptor Timeout(Time timeout) => Qs("timeout", timeout);

        /// <summary>The number of shard copies that must be active before proceeding with the operation. Set to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).</summary>
        public SplitIndexDescriptor WaitForActiveShards(string waitforactiveshards) =>
            Qs("wait_for_active_shards", waitforactiveshards);

        /// <summary>Should this request wait until the operation has completed before returning.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.7.0 or greater.</remarks>
        public SplitIndexDescriptor WaitForCompletion(bool? waitforcompletion = true) =>
            Qs("wait_for_completion", waitforcompletion);
    }

    /// <summary>Descriptor for Stats <para>https://opensearch.org/docs/latest</para></summary>
    public partial class IndicesStatsDescriptor
        : RequestDescriptorBase<
            IndicesStatsDescriptor,
            IndicesStatsRequestParameters,
            IIndicesStatsRequest
        >,
            IIndicesStatsRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesStats;

        /// <summary>/_stats</summary>
        public IndicesStatsDescriptor()
            : base() { }

        /// <summary>/{index}/_stats</summary>
        /// <param name="index">Optional, accepts null</param>
        public IndicesStatsDescriptor(Indices index)
            : base(r => r.Optional("index", index)) { }

        /// <summary>/{index}/_stats/{metric}</summary>
        /// <param name="index">Optional, accepts null</param>
        /// <param name="metric">Optional, accepts null</param>
        public IndicesStatsDescriptor(Indices index, Metrics metric)
            : base(r => r.Optional("index", index).Optional("metric", metric)) { }

        /// <summary>/_stats/{metric}</summary>
        /// <param name="metric">Optional, accepts null</param>
        public IndicesStatsDescriptor(Metrics metric)
            : base(r => r.Optional("metric", metric)) { }

        // values part of the url path
        Indices IIndicesStatsRequest.Index => Self.RouteValues.Get<Indices>("index");
        Metrics IIndicesStatsRequest.Metric => Self.RouteValues.Get<Metrics>("metric");

        /// <summary>A comma-separated list of index names; use the special string `_all` or Indices.All to perform the operation on all indexes.</summary>
        public IndicesStatsDescriptor Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Optional("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public IndicesStatsDescriptor Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public IndicesStatsDescriptor AllIndices() => Index(Indices.All);

        /// <summary>Limit the information returned the specific metrics.</summary>
        public IndicesStatsDescriptor Metric(Metrics metric) =>
            Assign(metric, (a, v) => a.RouteValues.Optional("metric", v));

        // Request parameters
        /// <summary>Comma-separated list or wildcard expressions of fields to include in field data and suggest statistics.</summary>
        public IndicesStatsDescriptor CompletionFields(Fields completionfields) =>
            Qs("completion_fields", completionfields);

        /// <summary>Comma-separated list or wildcard expressions of fields to include in field data and suggest statistics.</summary>
        public IndicesStatsDescriptor CompletionFields<T>(
            params Expression<Func<T, object>>[] fields
        )
            where T : class => Qs("completion_fields", fields?.Select(e => (Field)e));

        /// <summary>Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`.</summary>
        public IndicesStatsDescriptor ExpandWildcards(ExpandWildcards? expandwildcards) =>
            Qs("expand_wildcards", expandwildcards);

        /// <summary>Comma-separated list or wildcard expressions of fields to include in field data statistics.</summary>
        public IndicesStatsDescriptor FielddataFields(Fields fielddatafields) =>
            Qs("fielddata_fields", fielddatafields);

        /// <summary>Comma-separated list or wildcard expressions of fields to include in field data statistics.</summary>
        public IndicesStatsDescriptor FielddataFields<T>(
            params Expression<Func<T, object>>[] fields
        )
            where T : class => Qs("fielddata_fields", fields?.Select(e => (Field)e));

        /// <summary>Comma-separated list or wildcard expressions of fields to include in the statistics.</summary>
        public IndicesStatsDescriptor Fields(Fields fields) => Qs("fields", fields);

        /// <summary>Comma-separated list or wildcard expressions of fields to include in the statistics.</summary>
        public IndicesStatsDescriptor Fields<T>(params Expression<Func<T, object>>[] fields)
            where T : class => Qs("fields", fields?.Select(e => (Field)e));

        /// <summary>If `true`, statistics are not collected from closed indexes.</summary>
        public IndicesStatsDescriptor ForbidClosedIndices(bool? forbidclosedindices = true) =>
            Qs("forbid_closed_indices", forbidclosedindices);

        /// <summary>Comma-separated list of search groups to include in the search statistics.</summary>
        public IndicesStatsDescriptor Groups(params string[] groups) => Qs("groups", groups);

        /// <summary>If `true`, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).</summary>
        public IndicesStatsDescriptor IncludeSegmentFileSizes(
            bool? includesegmentfilesizes = true
        ) => Qs("include_segment_file_sizes", includesegmentfilesizes);

        /// <summary>If `true`, the response includes information from segments that are not loaded into memory.</summary>
        public IndicesStatsDescriptor IncludeUnloadedSegments(
            bool? includeunloadedsegments = true
        ) => Qs("include_unloaded_segments", includeunloadedsegments);

        /// <summary>Indicates whether statistics are aggregated at the cluster, index, or shard level.</summary>
        public IndicesStatsDescriptor Level(Level? level) => Qs("level", level);
    }

    /// <summary>Descriptor for BulkAlias <para>https://opensearch.org/docs/latest/api-reference/index-apis/alias/</para></summary>
    public partial class BulkAliasDescriptor
        : RequestDescriptorBase<BulkAliasDescriptor, BulkAliasRequestParameters, IBulkAliasRequest>,
            IBulkAliasRequest
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesBulkAlias;

        // values part of the url path
        // Request parameters
        /// <summary>Operation timeout for connection to cluster-manager node.</summary>
        /// <remarks>Supported by OpenSearch servers of version 2.0.0 or greater.</remarks>
        public BulkAliasDescriptor ClusterManagerTimeout(Time clustermanagertimeout) =>
            Qs("cluster_manager_timeout", clustermanagertimeout);

        /// <summary>Period to wait for a connection to the cluster-manager node. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        [Obsolete(
            "Deprecated as of: 2.0.0, reason: To promote inclusive language, use `cluster_manager_timeout` instead."
        )]
        public BulkAliasDescriptor MasterTimeout(Time mastertimeout) =>
            Qs("master_timeout", mastertimeout);

        /// <summary>Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.</summary>
        public BulkAliasDescriptor Timeout(Time timeout) => Qs("timeout", timeout);
    }

    /// <summary>Descriptor for ValidateQuery <para>https://opensearch.org/docs/latest</para></summary>
    public partial class ValidateQueryDescriptor<TDocument>
        : RequestDescriptorBase<
            ValidateQueryDescriptor<TDocument>,
            ValidateQueryRequestParameters,
            IValidateQueryRequest<TDocument>
        >,
            IValidateQueryRequest<TDocument>
    {
        internal override ApiUrls ApiUrls => ApiUrlsLookups.IndicesValidateQuery;

        /// <summary>/{index}/_validate/query</summary>
        public ValidateQueryDescriptor()
            : this(typeof(TDocument)) { }

        /// <summary>/{index}/_validate/query</summary>
        /// <param name="index">Optional, accepts null</param>
        public ValidateQueryDescriptor(Indices index)
            : base(r => r.Optional("index", index)) { }

        // values part of the url path
        Indices IValidateQueryRequest.Index => Self.RouteValues.Get<Indices>("index");

        /// <summary>Comma-separated list of data streams, indexes, and aliases to search. Supports wildcards (`*`). To search all data streams or indexes, omit this parameter or use `*` or `_all`.</summary>
        public ValidateQueryDescriptor<TDocument> Index(Indices index) =>
            Assign(index, (a, v) => a.RouteValues.Optional("index", v));

        /// <summary>a shortcut into calling Index(typeof(TOther))</summary>
        public ValidateQueryDescriptor<TDocument> Index<TOther>()
            where TOther : class =>
            Assign(typeof(TOther), (a, v) => a.RouteValues.Optional("index", (Indices)v));

        /// <summary>A shortcut into calling Index(Indices.All)</summary>
        public ValidateQueryDescriptor<TDocument> AllIndices() => Index(Indices.All);

        // Request parameters
        /// <summary>If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indexes. This behavior applies even if the request targets other open indexes.</summary>
        public ValidateQueryDescriptor<TDocument> AllowNoIndices(bool? allownoindices = true) =>
            Qs("allow_no_indices", allownoindices);

        /// <summary>If `true`, the validation is executed on all shards instead of one random shard per index.</summary>
        public ValidateQueryDescriptor<TDocument> AllShards(bool? allshards = true) =>
            Qs("all_shards", allshards);

        /// <summary>Analyzer to use for the query string. This parameter can only be used when the `q` query string parameter is specified.</summary>
        public ValidateQueryDescriptor<TDocument> Analyzer(string analyzer) =>
            Qs("analyzer", analyzer);

        /// <summary>If `true`, wildcard and prefix queries are analyzed.</summary>
        public ValidateQueryDescriptor<TDocument> AnalyzeWildcard(bool? analyzewildcard = true) =>
            Qs("analyze_wildcard", analyzewildcard);

        /// <summary>The default operator for query string query: `AND` or `OR`.</summary>
        public ValidateQueryDescriptor<TDocument> DefaultOperator(
            DefaultOperator? defaultoperator
        ) => Qs("default_operator", defaultoperator);

        /// <summary>Field to use as default where no field prefix is given in the query string. This parameter can only be used when the `q` query string parameter is specified.</summary>
        public ValidateQueryDescriptor<TDocument> Df(string df) => Qs("df", df);

        /// <summary>Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`. Valid values are: `all`, `open`, `closed`, `hidden`, `none`.</summary>
        public ValidateQueryDescriptor<TDocument> ExpandWildcards(
            ExpandWildcards? expandwildcards
        ) => Qs("expand_wildcards", expandwildcards);

        /// <summary>If `true`, the response returns detailed information if an error has occurred.</summary>
        public ValidateQueryDescriptor<TDocument> Explain(bool? explain = true) =>
            Qs("explain", explain);

        /// <summary>If `false`, the request returns an error if it targets a missing or closed index.</summary>
        public ValidateQueryDescriptor<TDocument> IgnoreUnavailable(
            bool? ignoreunavailable = true
        ) => Qs("ignore_unavailable", ignoreunavailable);

        /// <summary>If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.</summary>
        public ValidateQueryDescriptor<TDocument> Lenient(bool? lenient = true) =>
            Qs("lenient", lenient);

        /// <summary>Query in the Lucene query string syntax.</summary>
        public ValidateQueryDescriptor<TDocument> QueryOnQueryString(string queryonquerystring) =>
            Qs("q", queryonquerystring);

        /// <summary>If `true`, returns a more detailed explanation showing the actual Lucene query that will be executed.</summary>
        public ValidateQueryDescriptor<TDocument> Rewrite(bool? rewrite = true) =>
            Qs("rewrite", rewrite);
    }
}
