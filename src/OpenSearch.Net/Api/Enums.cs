/* SPDX-License-Identifier: Apache-2.0
*
* The OpenSearch Contributors require contributions made to
* this file be licensed under the Apache-2.0 license or a
* compatible open source license.
*/
/*
* Modifications Copyright OpenSearch Contributors. See
* GitHub history for details.
*
*  Licensed to Elasticsearch B.V. under one or more contributor
*  license agreements. See the NOTICE file distributed with
*  this work for additional information regarding copyright
*  ownership. Elasticsearch B.V. licenses this file to you under
*  the Apache License, Version 2.0 (the "License"); you may
*  not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
* 	http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing,
*  software distributed under the License is distributed on an
*  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
*  KIND, either express or implied.  See the License for the
*  specific language governing permissions and limitations
*  under the License.
*/
// ███╗   ██╗ ██████╗ ████████╗██╗ ██████╗███████╗
// ████╗  ██║██╔═══██╗╚══██╔══╝██║██╔════╝██╔════╝
// ██╔██╗ ██║██║   ██║   ██║   ██║██║     █████╗
// ██║╚██╗██║██║   ██║   ██║   ██║██║     ██╔══╝
// ██║ ╚████║╚██████╔╝   ██║   ██║╚██████╗███████╗
// ╚═╝  ╚═══╝ ╚═════╝    ╚═╝   ╚═╝ ╚═════╝╚══════╝
// -----------------------------------------------
//
// This file is automatically generated
// Please do not edit these files manually
// Run the following in the root of the repos:
//
// 		*NIX 		:	./build.sh codegen
// 		Windows 	:	build.bat codegen
//
// -----------------------------------------------
// ReSharper disable RedundantUsingDirective
using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Linq;
using System.Text;
using System.Reflection;
using System.Runtime.Serialization;

namespace OpenSearch.Net
{
	[Flags, StringEnum]
	public enum IndicesStatsMetric
	{
		[EnumMember(Value = "store")]
		Store = 1 << 0,
		[EnumMember(Value = "indexing")]
		Indexing = 1 << 1,
		[EnumMember(Value = "get")]
		Get = 1 << 2,
		[EnumMember(Value = "search")]
		Search = 1 << 3,
		[EnumMember(Value = "merge")]
		Merge = 1 << 4,
		[EnumMember(Value = "flush")]
		Flush = 1 << 5,
		[EnumMember(Value = "refresh")]
		Refresh = 1 << 6,
		[EnumMember(Value = "query_cache")]
		QueryCache = 1 << 7,
		[EnumMember(Value = "fielddata")]
		Fielddata = 1 << 8,
		[EnumMember(Value = "docs")]
		Docs = 1 << 9,
		[EnumMember(Value = "warmer")]
		Warmer = 1 << 10,
		[EnumMember(Value = "completion")]
		Completion = 1 << 11,
		[EnumMember(Value = "segments")]
		Segments = 1 << 12,
		[EnumMember(Value = "translog")]
		Translog = 1 << 13,
		[EnumMember(Value = "request_cache")]
		RequestCache = 1 << 14,
		[EnumMember(Value = "recovery")]
		Recovery = 1 << 15,
		[EnumMember(Value = "_all")]
		All = 1 << 16
	}

	[StringEnum]
	public enum DefaultOperator
	{
		[EnumMember(Value = "AND")]
		And,
		[EnumMember(Value = "OR")]
		Or
	}

	[StringEnum]
	public enum SearchType
	{
		[EnumMember(Value = "query_then_fetch")]
		QueryThenFetch,
		[EnumMember(Value = "dfs_query_then_fetch")]
		DfsQueryThenFetch
	}

	[StringEnum]
	public enum SuggestMode
	{
		[EnumMember(Value = "missing")]
		Missing,
		[EnumMember(Value = "popular")]
		Popular,
		[EnumMember(Value = "always")]
		Always
	}

	[StringEnum]
	public enum Refresh
	{
		[EnumMember(Value = "true")]
		True,
		[EnumMember(Value = "false")]
		False,
		[EnumMember(Value = "wait_for")]
		WaitFor
	}

	[StringEnum]
	public enum Health
	{
		[EnumMember(Value = "green")]
		Green,
		[EnumMember(Value = "yellow")]
		Yellow,
		[EnumMember(Value = "red")]
		Red
	}

	[StringEnum]
	public enum Size
	{
		[EnumMember(Value = "")]
		Raw,
		[EnumMember(Value = "k")]
		K,
		[EnumMember(Value = "m")]
		M,
		[EnumMember(Value = "g")]
		G,
		[EnumMember(Value = "t")]
		T,
		[EnumMember(Value = "p")]
		P
	}

	[StringEnum]
	public enum Level
	{
		[EnumMember(Value = "cluster")]
		Cluster,
		[EnumMember(Value = "indices")]
		Indices,
		[EnumMember(Value = "shards")]
		Shards
	}

	[Flags, StringEnum]
	public enum ClusterRerouteMetric
	{
		[EnumMember(Value = "blocks")]
		Blocks = 1 << 0,
		[EnumMember(Value = "metadata")]
		Metadata = 1 << 1,
		[EnumMember(Value = "nodes")]
		Nodes = 1 << 2,
		[EnumMember(Value = "routing_table")]
		RoutingTable = 1 << 3,
		[EnumMember(Value = "master_node")]
		MasterNode = 1 << 4,
		[EnumMember(Value = "version")]
		Version = 1 << 5,
		[EnumMember(Value = "_all")]
		All = 1 << 6
	}

	[StringEnum]
	public enum VersionType
	{
		[EnumMember(Value = "internal")]
		Internal,
		[EnumMember(Value = "external")]
		External,
		[EnumMember(Value = "external_gte")]
		ExternalGte,
	}

	[StringEnum]
	public enum Conflicts
	{
		[EnumMember(Value = "abort")]
		Abort,
		[EnumMember(Value = "proceed")]
		Proceed
	}

	[StringEnum]
	public enum OpType
	{
		[EnumMember(Value = "index")]
		Index,
		[EnumMember(Value = "create")]
		Create
	}

	[StringEnum]
	public enum IndicesShardStoresStatus
	{
		[EnumMember(Value = "green")]
		Green,
		[EnumMember(Value = "yellow")]
		Yellow,
		[EnumMember(Value = "red")]
		Red,
		[EnumMember(Value = "all")]
		All
	}

	[StringEnum]
	public enum ThreadType
	{
		[EnumMember(Value = "cpu")]
		Cpu,
		[EnumMember(Value = "wait")]
		Wait,
		[EnumMember(Value = "block")]
		Block
	}

	public static partial class KnownEnums
	{
		private static readonly ConcurrentDictionary<Type, Func<Enum, string>> EnumStringResolvers = new ConcurrentDictionary<Type, Func<Enum, string>>();
		static KnownEnums()
		{
			EnumStringResolvers.TryAdd(typeof(IndicesStatsMetric), (e) => GetStringValue((IndicesStatsMetric)e));
			EnumStringResolvers.TryAdd(typeof(DefaultOperator), (e) => GetStringValue((DefaultOperator)e));
			EnumStringResolvers.TryAdd(typeof(SearchType), (e) => GetStringValue((SearchType)e));
			EnumStringResolvers.TryAdd(typeof(SuggestMode), (e) => GetStringValue((SuggestMode)e));
			EnumStringResolvers.TryAdd(typeof(Refresh), (e) => GetStringValue((Refresh)e));
			EnumStringResolvers.TryAdd(typeof(Health), (e) => GetStringValue((Health)e));
			EnumStringResolvers.TryAdd(typeof(Size), (e) => GetStringValue((Size)e));
			EnumStringResolvers.TryAdd(typeof(Level), (e) => GetStringValue((Level)e));
			EnumStringResolvers.TryAdd(typeof(ClusterRerouteMetric), (e) => GetStringValue((ClusterRerouteMetric)e));
			EnumStringResolvers.TryAdd(typeof(VersionType), (e) => GetStringValue((VersionType)e));
			EnumStringResolvers.TryAdd(typeof(Conflicts), (e) => GetStringValue((Conflicts)e));
			EnumStringResolvers.TryAdd(typeof(OpType), (e) => GetStringValue((OpType)e));
			EnumStringResolvers.TryAdd(typeof(IndicesShardStoresStatus), (e) => GetStringValue((IndicesShardStoresStatus)e));
			EnumStringResolvers.TryAdd(typeof(ThreadType), (e) => GetStringValue((ThreadType)e));
			RegisterEnumStringResolvers();
		}

		static partial void RegisterEnumStringResolvers();

		private class EnumDictionary : Dictionary<Enum, string>
		{
			public EnumDictionary(int capacity): base(capacity)
			{
			}

			public Func<Enum, string> Resolver
			{
				get;
				set;
			}
		}

		public static string GetStringValue(this IndicesStatsMetric enumValue)
		{
			if ((enumValue & IndicesStatsMetric.All) != 0)
				return "_all";
			var list = new List<string>();
			if ((enumValue & IndicesStatsMetric.Store) != 0)
				list.Add("store");
			if ((enumValue & IndicesStatsMetric.Indexing) != 0)
				list.Add("indexing");
			if ((enumValue & IndicesStatsMetric.Get) != 0)
				list.Add("get");
			if ((enumValue & IndicesStatsMetric.Search) != 0)
				list.Add("search");
			if ((enumValue & IndicesStatsMetric.Merge) != 0)
				list.Add("merge");
			if ((enumValue & IndicesStatsMetric.Flush) != 0)
				list.Add("flush");
			if ((enumValue & IndicesStatsMetric.Refresh) != 0)
				list.Add("refresh");
			if ((enumValue & IndicesStatsMetric.QueryCache) != 0)
				list.Add("query_cache");
			if ((enumValue & IndicesStatsMetric.Fielddata) != 0)
				list.Add("fielddata");
			if ((enumValue & IndicesStatsMetric.Docs) != 0)
				list.Add("docs");
			if ((enumValue & IndicesStatsMetric.Warmer) != 0)
				list.Add("warmer");
			if ((enumValue & IndicesStatsMetric.Completion) != 0)
				list.Add("completion");
			if ((enumValue & IndicesStatsMetric.Segments) != 0)
				list.Add("segments");
			if ((enumValue & IndicesStatsMetric.Translog) != 0)
				list.Add("translog");
			if ((enumValue & IndicesStatsMetric.RequestCache) != 0)
				list.Add("request_cache");
			if ((enumValue & IndicesStatsMetric.Recovery) != 0)
				list.Add("recovery");
			return string.Join(",", list);
		}

		public static string GetStringValue(this DefaultOperator enumValue)
		{
			switch (enumValue)
			{
				case DefaultOperator.And:
					return "AND";
				case DefaultOperator.Or:
					return "OR";
			}

			throw new ArgumentException($"'{enumValue.ToString()}' is not a valid value for enum 'DefaultOperator'");
		}

		public static string GetStringValue(this SearchType enumValue)
		{
			switch (enumValue)
			{
				case SearchType.QueryThenFetch:
					return "query_then_fetch";
				case SearchType.DfsQueryThenFetch:
					return "dfs_query_then_fetch";
			}

			throw new ArgumentException($"'{enumValue.ToString()}' is not a valid value for enum 'SearchType'");
		}

		public static string GetStringValue(this SuggestMode enumValue)
		{
			switch (enumValue)
			{
				case SuggestMode.Missing:
					return "missing";
				case SuggestMode.Popular:
					return "popular";
				case SuggestMode.Always:
					return "always";
			}

			throw new ArgumentException($"'{enumValue.ToString()}' is not a valid value for enum 'SuggestMode'");
		}

		public static string GetStringValue(this Refresh enumValue)
		{
			switch (enumValue)
			{
				case Refresh.True:
					return "true";
				case Refresh.False:
					return "false";
				case Refresh.WaitFor:
					return "wait_for";
			}

			throw new ArgumentException($"'{enumValue.ToString()}' is not a valid value for enum 'Refresh'");
		}

		public static string GetStringValue(this Health enumValue)
		{
			switch (enumValue)
			{
				case Health.Green:
					return "green";
				case Health.Yellow:
					return "yellow";
				case Health.Red:
					return "red";
			}

			throw new ArgumentException($"'{enumValue.ToString()}' is not a valid value for enum 'Health'");
		}

		public static string GetStringValue(this Size enumValue)
		{
			switch (enumValue)
			{
				case Size.Raw:
					return "";
				case Size.K:
					return "k";
				case Size.M:
					return "m";
				case Size.G:
					return "g";
				case Size.T:
					return "t";
				case Size.P:
					return "p";
			}

			throw new ArgumentException($"'{enumValue.ToString()}' is not a valid value for enum 'Size'");
		}

		public static string GetStringValue(this Level enumValue)
		{
			switch (enumValue)
			{
				case Level.Cluster:
					return "cluster";
				case Level.Indices:
					return "indices";
				case Level.Shards:
					return "shards";
			}

			throw new ArgumentException($"'{enumValue.ToString()}' is not a valid value for enum 'Level'");
		}

		public static string GetStringValue(this ClusterRerouteMetric enumValue)
		{
			if ((enumValue & ClusterRerouteMetric.All) != 0)
				return "_all";
			var list = new List<string>();
			if ((enumValue & ClusterRerouteMetric.Blocks) != 0)
				list.Add("blocks");
			if ((enumValue & ClusterRerouteMetric.Metadata) != 0)
				list.Add("metadata");
			if ((enumValue & ClusterRerouteMetric.Nodes) != 0)
				list.Add("nodes");
			if ((enumValue & ClusterRerouteMetric.RoutingTable) != 0)
				list.Add("routing_table");
			if ((enumValue & ClusterRerouteMetric.MasterNode) != 0)
				list.Add("master_node");
			if ((enumValue & ClusterRerouteMetric.Version) != 0)
				list.Add("version");
			return string.Join(",", list);
		}

		public static string GetStringValue(this VersionType enumValue)
		{
			switch (enumValue)
			{
				case VersionType.Internal:
					return "internal";
				case VersionType.External:
					return "external";
				case VersionType.ExternalGte:
					return "external_gte";
			}

			throw new ArgumentException($"'{enumValue.ToString()}' is not a valid value for enum 'VersionType'");
		}

		public static string GetStringValue(this Conflicts enumValue)
		{
			switch (enumValue)
			{
				case Conflicts.Abort:
					return "abort";
				case Conflicts.Proceed:
					return "proceed";
			}

			throw new ArgumentException($"'{enumValue.ToString()}' is not a valid value for enum 'Conflicts'");
		}

		public static string GetStringValue(this OpType enumValue)
		{
			switch (enumValue)
			{
				case OpType.Index:
					return "index";
				case OpType.Create:
					return "create";
			}

			throw new ArgumentException($"'{enumValue.ToString()}' is not a valid value for enum 'OpType'");
		}

		public static string GetStringValue(this IndicesShardStoresStatus enumValue)
		{
			switch (enumValue)
			{
				case IndicesShardStoresStatus.Green:
					return "green";
				case IndicesShardStoresStatus.Yellow:
					return "yellow";
				case IndicesShardStoresStatus.Red:
					return "red";
				case IndicesShardStoresStatus.All:
					return "all";
			}

			throw new ArgumentException($"'{enumValue.ToString()}' is not a valid value for enum 'IndicesShardStoresStatus'");
		}

		public static string GetStringValue(this ThreadType enumValue)
		{
			switch (enumValue)
			{
				case ThreadType.Cpu:
					return "cpu";
				case ThreadType.Wait:
					return "wait";
				case ThreadType.Block:
					return "block";
			}

			throw new ArgumentException($"'{enumValue.ToString()}' is not a valid value for enum 'ThreadType'");
		}

		public static string GetStringValue(this Enum e)
		{
			var type = e.GetType();
			var resolver = EnumStringResolvers.GetOrAdd(type, GetEnumStringResolver);
			return resolver(e);
		}

		private static Func<Enum, string> GetEnumStringResolver(Type type)
		{
			var values = Enum.GetValues(type);
			var dictionary = new EnumDictionary(values.Length);
			for (var index = 0; index < values.Length; index++)
			{
				var value = values.GetValue(index);
				var info = type.GetField(value.ToString());
				var da = (EnumMemberAttribute[])info.GetCustomAttributes(typeof(EnumMemberAttribute), false);
				var stringValue = da.Length > 0 ? da[0].Value : Enum.GetName(type, value);
				dictionary.Add((Enum)value, stringValue);
			}

			var isFlag = type.GetCustomAttributes(typeof(FlagsAttribute), false).Length > 0;
			return (e) =>
			{
				if (isFlag)
				{
					var list = new List<string>();
					foreach (var kv in dictionary)
					{
						if (e.HasFlag(kv.Key))
							list.Add(kv.Value);
					}

					return string.Join(",", list);
				}
				else
				{
					return dictionary[e];
				}
			}

			;
		}
	}
}
